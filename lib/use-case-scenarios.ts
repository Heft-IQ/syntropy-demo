export interface UseCaseScenario {
  id: string;
  title: string;
  description: string;
  category: 'elt' | 'troubleshooting' | 'governance' | 'integration';
  steps: Array<{
    step: number;
    title: string;
    description: string;
    component?: string;
    codeExample?: string;
  }>;
  keyTakeaways: string[];
  relatedComponents: string[];
}

export const USE_CASE_SCENARIOS: UseCaseScenario[] = [
  {
    id: 'add-new-erp',
    title: 'Adding a New ERP System (ELT Workflow)',
    description: 'Learn how to add a new ERP system to the platform using the ELT approach. This demonstrates the flexibility of ELT when handling new data sources.',
    category: 'elt',
    steps: [
      {
        step: 1,
        title: 'Create Connector',
        description: 'Create a new connector in the dlt Worker for the ERP system (e.g., SAP, Oracle). Define the API endpoints and authentication.',
        component: 'dlt Worker',
        codeExample: `# /connectors/sap_erp/__init__.py
from dlt.sources.rest_api import rest_api_source

def sap_connector():
    return rest_api_source(
        base_url="https://api.sap.com",
        endpoints=["transactions", "customers"]
    )`,
      },
      {
        step: 2,
        title: 'Extract Raw Data',
        description: 'dlt Worker extracts raw JSON data from the new ERP via REST API. No transformation happens yet - this is the "Extract" step in ELT.',
        component: 'ERP → dlt Worker',
      },
      {
        step: 3,
        title: 'Load to S3 Bronze',
        description: 'Raw data is loaded into S3 Bronze in Parquet format, organized by vendor. The raw data structure is preserved - this is the "Load" step.',
        component: 'dlt Worker → S3 Bronze',
      },
      {
        step: 4,
        title: 'Register in Knowledge Graph',
        description: 'Register the new ERP tables and columns in FalkorDB Graph. Map physical columns to canonical business terms.',
        component: 'FalkorDB Graph',
        codeExample: `// Register SAP table
CREATE (:VendorTable {
  name: 'BSEG',
  source: 'sap',
  tenant_id: 'cust_gamma'
});

// Map to canonical
MATCH (c:VendorColumn {name: 'DMBTR'})
MATCH (a:CanonicalAttribute {name: 'GrossRevenue'})
CREATE (c)-[:MAPS_TO]->(a);`,
      },
      {
        step: 5,
        title: 'Transform in Tinybird',
        description: 'Tinybird auto-ingests from S3 and applies transformations. Create new metrics or queries using the new ERP data - this is the "Transform" step.',
        component: 'Tinybird',
      },
    ],
    keyTakeaways: [
      'ELT allows adding new sources without breaking existing pipelines',
      'Raw data is preserved in S3 Bronze for future use cases',
      'Transformations happen after ingestion, not during',
      'Knowledge Graph enables semantic mapping across vendors',
    ],
    relatedComponents: ['erp', 'worker', 's3', 'falkordb', 'tinybird'],
  },
  {
    id: 'debug-slow-query',
    title: 'Debugging a Slow Query',
    description: 'Troubleshoot performance issues in metric queries by understanding the query flow and identifying bottlenecks.',
    category: 'troubleshooting',
    steps: [
      {
        step: 1,
        title: 'Check Query in Audit Log',
        description: 'Find the query in the Audit Log. Look at the duration, filters, and metadata to understand what was requested.',
        component: 'Audit Log',
      },
      {
        step: 2,
        title: 'Verify Permissions',
        description: 'Check if Clerk Auth validation is causing delays. Review JWT token validation time in the audit log.',
        component: 'Clerk Auth',
      },
      {
        step: 3,
        title: 'Check Schema Resolution',
        description: 'Verify FalkorDB Graph query performance. Slow schema resolution can indicate missing indexes or complex mappings.',
        component: 'FalkorDB Graph',
      },
      {
        step: 4,
        title: 'Analyze Tinybird Query',
        description: 'Review the SQL query generated by Cube Gateway. Check if it\'s using proper indexes and filters.',
        component: 'Tinybird',
        codeExample: `-- Check query execution plan
EXPLAIN SELECT 
  SUM(gross_revenue) - SUM(returns) - SUM(tax) as net_revenue
FROM transactions
WHERE date >= '2024-01-01'
GROUP BY month;`,
      },
      {
        step: 5,
        title: 'Optimize if Needed',
        description: 'If query is slow, consider: adding indexes, optimizing filters, caching results, or pre-aggregating data in Tinybird.',
        component: 'Tinybird',
      },
    ],
    keyTakeaways: [
      'Use Audit Log to track query performance',
      'Check each step in the query flow for bottlenecks',
      'Tinybird query optimization is key for performance',
      'Caching can help with repeated queries',
    ],
    relatedComponents: ['cube', 'clerk', 'falkordb', 'tinybird'],
  },
  {
    id: 'approve-new-metric',
    title: 'Approving a New Metric',
    description: 'Complete workflow for reviewing and approving a new metric definition, including impact analysis and governance.',
    category: 'governance',
    steps: [
      {
        step: 1,
        title: 'Review Metric Definition',
        description: 'View the pending metric in the Semantic Layer. Review the business logic, code, and justification provided by the requester.',
        component: 'Enterprise Dashboard',
      },
      {
        step: 2,
        title: 'Check Impact Analysis',
        description: 'Click "Review" to see the impact analysis. This shows how the metric affects existing queries and dashboards.',
        component: 'Impact Review Modal',
      },
      {
        step: 3,
        title: 'Verify Data Lineage',
        description: 'Check the data lineage to understand which source fields and canonical fields the metric depends on.',
        component: 'Data Lineage',
      },
      {
        step: 4,
        title: 'Test the Metric',
        description: 'Run a test query to verify the metric calculation is correct. Check results against expected values.',
        component: 'Cube Gateway',
      },
      {
        step: 5,
        title: 'Approve or Reject',
        description: 'If approved, the metric becomes active and available for use. If rejected, provide feedback for the requester.',
        component: 'Enterprise Dashboard',
      },
    ],
    keyTakeaways: [
      'Always review impact analysis before approving',
      'Verify data lineage to understand dependencies',
      'Test metrics before making them active',
      'Audit log tracks all approval decisions',
    ],
    relatedComponents: ['cube', 'falkordb', 'tinybird'],
  },
  {
    id: 'handle-schema-changes',
    title: 'Handling Schema Changes (ELT Flexibility)',
    description: 'Demonstrate how ELT handles schema changes gracefully, without breaking the ingestion pipeline.',
    category: 'elt',
    steps: [
      {
        step: 1,
        title: 'ERP Adds New Field',
        description: 'ERP system (e.g., NetSuite) adds a new field to the transactions table. In ETL, this would break the pipeline. In ELT, ingestion continues.',
        component: 'ERP',
      },
      {
        step: 2,
        title: 'Raw Data Loaded',
        description: 'dlt Worker loads the new field along with existing data into S3 Bronze. No transformation logic needs updating yet.',
        component: 'dlt Worker → S3 Bronze',
      },
      {
        step: 3,
        title: 'Update Knowledge Graph',
        description: 'Register the new field in FalkorDB Graph. Map it to a canonical field if needed, or leave it unmapped for now.',
        component: 'FalkorDB Graph',
        codeExample: `// Register new field
CREATE (:VendorColumn {
  name: 'NEW_FIELD',
  type: 'varchar',
  source: 'netsuite',
  tenant_id: 'cust_acme'
});

// Optional: Map to canonical
MATCH (c:VendorColumn {name: 'NEW_FIELD'})
MATCH (a:CanonicalAttribute {name: 'NewBusinessTerm'})
CREATE (c)-[:MAPS_TO]->(a);`,
      },
      {
        step: 4,
        title: 'Update Transformations (Optional)',
        description: 'If you want to use the new field, update transformations in Tinybird. Existing queries continue working unchanged.',
        component: 'Tinybird',
      },
      {
        step: 5,
        title: 'Create New Metrics',
        description: 'Use the new field to create new metrics or enhance existing ones. The raw data was preserved, so you can backfill if needed.',
        component: 'Semantic Layer',
      },
    ],
    keyTakeaways: [
      'ELT handles schema changes without breaking ingestion',
      'Raw data is preserved, enabling backfilling',
      'Transformations can be updated independently',
      'No need to modify ingestion pipeline for schema changes',
    ],
    relatedComponents: ['erp', 'worker', 's3', 'falkordb', 'tinybird'],
  },
];

export function getScenario(id: string): UseCaseScenario | undefined {
  return USE_CASE_SCENARIOS.find(s => s.id === id);
}

export function getScenariosByCategory(category: UseCaseScenario['category']): UseCaseScenario[] {
  return USE_CASE_SCENARIOS.filter(s => s.category === category);
}

